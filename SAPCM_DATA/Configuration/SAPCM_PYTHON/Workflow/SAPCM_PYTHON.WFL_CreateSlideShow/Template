<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<exportmultiplex category="Template" ref_path="workflow_data[Internal]/storable[workflow_data]/storable[Data]">
   <storable name="Audit Profile" null="true"/>
   <int name="Cancel batch count" value="0"/>
   <int name="Cancel batch type" value="0"/>
   <list classname="java.util.ArrayList" name="Comments"/>
   <storable name="Data Veracity Profile" null="true"/>
   <storable name="Error UDR type name" null="true"/>
   <boolean name="Error batch type" value="false"/>
   <string name="Error code" null="true"/>
   <map name="Error map" null="true"/>
   <storable name="Execution Config" storable-id="dr.WorkflowExecutionConfig" ver="10.0">
      <enum name="debugType" storable-id="dr.DebugType" value="EVENT"/>
      <storable name="executionSettings" storable-id="dr.ExecutionSettings" ver="11.0">
         <boolean name="enabled" value="false"/>
         <storable name="kafka" null="true"/>
      </storable>
      <int name="noOfFilesToKeep" value="0"/>
      <string name="throughputMIM" null="true"/>
      <string name="txnHandler" value="Default Handler"/>
   </storable>
   <list classname="java.util.ArrayList" name="Field Types"/>
   <boolean name="Log On CB" value="false"/>
   <list classname="java.util.ArrayList" name="Logged error MIM"/>
   <list classname="java.util.ArrayList" name="Nodes">
      <storable name="0" storable-id="dr.WfNode" ver="2.0">
         <string name="Classname"><![CDATA[com.digitalroute.pythonagents.agent.PythonBatchCollectionAgentInsp]]></string>
         <array classname="com.digitalroute.wf.WfNodeConfig" name="Configuration" size="1">
            <storable name="0" storable-id="dr.WfNodeConfig" ver="1.0">
               <string name="Classname"><![CDATA[com.digitalroute.pythonagents.agent.PythonBatchCollectionAgentInsp]]></string>
               <storable name="Data" storable-id="dr.PythonAgentData" ver="10.0">
                  <array name="inputTypes" null="true"/>
                  <storable name="interpreter" null="true"/>
                  <array name="mims" null="true"/>
                  <array classname="com.digitalroute.pythonagents.OutputTypeInfo" name="outputTypes" size="2">
                     <storable name="0" storable-id="dr.PythonOutputTypeInfo" ver="1.0">
                        <string name="route" null="true"/>
                        <storable name="udrTypeInfo" storable-id="dr.DRTypeInfo" ver="1.0">
                           <string name="TypeName" value="bytearray"/>
                        </storable>
                     </storable>
                     <storable name="1" storable-id="dr.PythonOutputTypeInfo" ver="1.0">
                        <string name="route" null="true"/>
                        <storable name="udrTypeInfo" storable-id="dr.DRTypeInfo" ver="1.0">
                           <string name="TypeName" value="DRUDR"/>
                        </storable>
                     </storable>
                  </array>
                  <string name="sourceCode"><![CDATA[import os
import sys
from datetime import datetime, date


from PIL import Image

# âœ… Patch for backward compatibility (Pillow >= 10)
if not hasattr(Image, 'ANTIALIAS'):
    Image.ANTIALIAS = Image.Resampling.LANCZOS

from moviepy.editor import ImageClip, AudioFileClip, concatenate_videoclips


def execute():
    beginBatch()
    
    print("Running Python from:", sys.executable)
    print("Python version:", sys.version)

    post_images, post_audios, comment_images, comment_audios = get_today_files()
    
    # Combine in required order: posts first, then comments
    all_images = post_images + comment_images
    all_audios = post_audios + comment_audios
    
    if all_images and all_audios:
        images_and_audio_to_video(all_images, all_audios)
    endBatch()

def get_today_files(base_dir="/opt/mz/Jai/RedditApp"):
    """
    Returns (post_images, post_audios, comment_images, comment_audios) for today's date.
    """
    today_str = datetime.now().strftime("%Y%m%d") 
    base_today = os.path.join(base_dir, today_str)

    def collect_files(subdir):
        path = os.path.join(base_today, subdir)
        images, audios = [], []
        if os.path.exists(path):
            for f in sorted(os.listdir(path)):
                full_path = os.path.join(path, f)
                if f.lower().endswith(".png"):
                    images.append(full_path)
                elif f.lower().endswith(".mp3"):
                    audios.append(full_path)
        return images, audios

    post_images, post_audios = collect_files("post")
    comment_images, comment_audios = collect_files("comment")
    return post_images, post_audios, comment_images, comment_audios
    
def images_and_audio_to_video(image_files, audio_files):
    """
    Create a video slideshow from matching lists of images and audio.
    Each image is shown for the duration of its audio.
    Saves the output inside today's dir: /opt/mz/Jai/RedditApp/YYYYMMDD/
    """
    clips = []

    for img, audio in zip(image_files, audio_files):
        audio_clip = AudioFileClip(audio)
        img_clip = ImageClip(img).set_duration(audio_clip.duration)
        img_clip = img_clip.set_audio(audio_clip)

        # Optional: resize image to 720p
        img_clip = img_clip.resize(height=720)

        clips.append(img_clip)

    # Concatenate all image+audio segments
    final_video = concatenate_videoclips(clips, method="compose")

    # Build dynamic save path
    today = date.today().strftime("%Y%m%d")
    save_dir = f"/opt/mz/Jai/RedditApp/{today}"
    os.makedirs(save_dir, exist_ok=True)  # make sure dir exists

    output_file = os.path.join(save_dir, "slideshow_post_then_comment.mp4")

    # Save video
    final_video.write_videofile(output_file, fps=24)

    return output_file
]]></string>
               </storable>
            </storable>
         </array>
         <string name="Name" value="Python_1"/>
      </storable>
      <storable name="1" storable-id="dr.WfNode" ver="2.0">
         <string name="Classname" value="com.digitalroute.wfc.analysis.StuffyMapperInsp"/>
         <array classname="com.digitalroute.wf.WfNodeConfig" name="Configuration" size="2">
            <storable name="0" storable-id="dr.WfNodeConfig" ver="1.0">
               <string name="Classname" value="com.digitalroute.wfc.analysis.StuffyMapperInsp"/>
               <storable name="Data" storable-id="dr.StuffyMapperData" ver="10.0">
                  <string name="sourceCode"><![CDATA[consume {

}]]></string>
                  <array classname="com.digitalroute.devkit.drudr.DRTypeInfo" name="udrTypes" size="2">
                     <storable name="0" storable-id="dr.DRTypeInfo" ver="1.0">
                        <string name="TypeName" value="bytearray"/>
                     </storable>
                     <storable name="1" storable-id="dr.DRTypeInfo" ver="1.0">
                        <string name="TypeName" value="DRUDR"/>
                     </storable>
                  </array>
               </storable>
            </storable>
            <storable name="1" storable-id="dr.WfNodeConfig" ver="1.0">
               <string name="Classname" value="com.digitalroute.devkit.hidden.DRThreadBufferInsp"/>
               <storable name="Data" storable-id="dr.DRThreadBufferConfig" ver="10.0">
                  <boolean name="printStats" value="false"/>
                  <boolean name="useOwnThread" value="false"/>
               </storable>
            </storable>
         </array>
         <string name="Name" value="Analysis_1"/>
      </storable>
   </list>
   <list classname="java.util.ArrayList" name="Routes">
      <storable name="0" storable-id="dr.WfRoute" ver="2.0">
         <string name="Name" value="r_1"/>
         <int name="Realtime mode" value="0"/>
      </storable>
   </list>
   <list classname="java.util.ArrayList" name="Service"/>
   <boolean name="Template Valid" value="true"/>
</exportmultiplex>
